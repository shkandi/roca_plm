-- ea_uart.vhd
-- Атоматы интерфейса UART

LIBRARY ieee;

USE ieee.std_logic_1164.all;
USE ieee.std_logic_unsigned.all;
USE ieee.std_logic_arith.all;

entity ea_uart is
port (
	reset: in std_logic; -- Сброс
	clk: in std_logic; -- Такт
	uart_rx: in std_logic; -- Прием Rx
	uart_tx: out std_logic; -- Передача Tx
	ur_com: buffer std_logic_vector (2 downto 0); -- Команда 
	ur_nbt: out std_logic_vector (5 downto 0); -- Количество байт в команде
	ur_regadr: out std_logic_vector (3 downto 0); -- Для адреса регистра
	ur_ramadr: buffer std_logic_vector (13 downto 0); -- Для адреса RAM
	ur_data: out std_logic_vector (7 downto 0); -- Принятые данные 
	data_uaramr: in std_logic_vector(7 downto 0); -- Данные от RAM
	data_uaregr: in std_logic_vector(7 downto 0); -- Данные от REG
	uswork_flag: out std_logic; -- Флаг работы UART send 
	ur_trig: buffer std_logic; -- Триггер принятых данных
	uaramsend_trig: in std_logic; -- Триггер от RAM
	uaregsend_trig: in std_logic -- Триггер от REG
);		
end ea_uart;

architecture Behavioral of ea_uart is
	
constant per: integer:= 2604;  -- Скорость UART, 2600 это 19200 бод ???
constant per14: integer:= 650; -- 1/4 интервала при 19200 ???

signal ur_buf: std_logic_vector(7 downto 0); -- Буфер приема
signal us_buf: std_logic_vector(7 downto 0); -- Буфер отправки

Begin

-- UART receive 
process (clk)
variable state: integer range 0 to 63; -- Состояние
variable count_tp: integer range 0 to per + 1; -- Счетчик периода и выборки бита
variable sum_tp: integer range 0 to 4; -- Сумма выборок бита
variable num_tp: integer range 0 to 4; -- Номер выборки бита 
variable count_bit: integer range 0 to 8; -- Счетчик битов
variable ur_bcount: integer range 0 to 256; -- Счетчик принятых байтов
variable header_flag: std_logic; -- Флаг заголовка пакета
begin
if (reset = '0') then -- Сброс
	count_tp:= 0;
	sum_tp:= 0;
	num_tp:= 0;
	count_bit:= 0;
	ur_bcount:= 0;
	header_flag:= '0';
	state:= 0;
elsif (rising_edge(clk) and reset = '1') then
	if (state = 0) then -- Состояние 0. Ожидание старт-бита
		if (uart_rx = '0') then -- Если есть признак старт бита
			state:= 1;
			count_tp:= 0;
		else -- Если нет признака старт бита
			if (ur_bcount > 0) then -- Если счетчик байт больше 0 
					if (count_tp < per) then -- Таймер периода  	
						count_tp:= count_tp + 1; 
					else -- Если не было старт-бита за период, то обнуляем счетчик принятых байт
						header_flag:= '0'; -- Снимаем флаг заголовка пакета
						ur_bcount:= 0; -- Счетчик принятых байт = 0
						count_tp:= 0;
					end if;	
			end if;
		end if;
	elsif (state = 1) then -- Состояние 1. Проверка старт бита
		if (count_tp < per14) then -- Таймер 1/4 периода
			count_tp:= count_tp + 1; 
		else
			count_tp:= 0;
			if (num_tp < 3) then -- Счетчик выборки
				if (uart_rx = '1') then -- Выборка старт бита
					sum_tp:= sum_tp + 1; -- Сумма результатов выборки
				end if;
				num_tp:= num_tp + 1; -- Счетчик выборки +1
			else -- Если сделали 3 выборки старт бита
				num_tp:= 0; -- Обнуляем счетчик выборки
				if (sum_tp < 2) then -- Если выборка в пользу старт бита,
					state:= 2; -- то переходим на состояние 2
				else -- Если выборка не в пользу старт бита, 
					state:= 0; -- то уходим на состояние 1
				end if;
				sum_tp:= 0; -- Обнуляем сумму выборки
			end if;
		end if;
	elsif (state = 2) then -- Состояние 2. Прием битов
		if (count_bit < 8) then -- Счетчик принятых битов
			if (count_tp < per14) then -- Таймер 1/4 периода
				count_tp:= count_tp + 1; 
			else 
				count_tp:= 0;	
				if (num_tp < 3) then -- Счетчик выборки
					if (uart_rx = '1') then -- Выборка
							sum_tp:= sum_tp + 1; -- Сумма результатов выборки
					end if; 
					num_tp:= num_tp + 1; -- Счетчик выборки +1	
				else -- Если сделали 3 выборки бита данных
					num_tp:= 0; -- Обнуляем счетчик выборки	
					ur_buf<= to_stdlogicvector(to_bitvector(ur_buf) ror 1); -- Сдвигаем буфер на 1 вправо
					if (sum_tp > 2) then -- Если выборка в пользу 1,
						ur_buf(7)<= '1'; -- то записываем 1 
					else -- Если нет,
						ur_buf(7)<= '0'; -- то записываем 0 
					end if;
					count_bit:= count_bit + 1; -- Сетчик битов +1
					sum_tp:= 0; -- Обнуляем сумму выборки
				end if;
			end if;
		else -- Если 8 бит принято
			count_bit:= 0; -- Сбрысываем счетчик битов
			state:= 3; -- Переходим на состояние 4 проверки стоп бита
		end if;
	elsif (state = 3) then -- Состояние 3. Проверка стоп бита
		if (count_tp < per14) then -- Таймер 1/4 периода	
			count_tp:= count_tp + 1; 
		else	
			count_tp:= 0;
			if (num_tp < 2) then -- Счетчик выборки
				if (uart_rx = '1') then -- Выборка стоп бита
					sum_tp:= sum_tp + 1; -- Сумма результатов выборки 
				end if;
				num_tp:= num_tp + 1; -- Счетчик выборки +1
			else -- Если сделали 2 выборки стоп бита
				num_tp:= 0; -- Обнуляем счетчик выборки
				if (sum_tp > 1) then -- Если выборка в пользу стоп бита,
					state:= 4; -- то переходим на состояние 4
				else -- Если выборка не в пользу стоп бита,												
					state:= 0;  -- то переходим на состояние 0
				end if;				
				sum_tp:= 0; -- Обнуляем сумму выборки
			end if;
		end if;
	elsif (state = 4) then -- Состояние 4. Счетчик байтов
		if (ur_bcount < 255) then -- Если количество байт меньше заглавных
			ur_bcount:= ur_bcount + 1; -- Увеличиваем счетчик байтов
		end if;
		state:= 5;
	elsif (state = 5) then -- Состояние 5. Оперируем байт в зависитмотси от его номера
		if (ur_bcount = 1) then
			if (ur_buf = x"aa") then -- Если есть признак заголовка пакета
				header_flag:= '1'; -- Ставим флаг заголовка пакета
			end if;
		elsif (ur_bcount = 2) then
			if (header_flag = '1') then -- Если был заголовок пакета
				ur_com <= ur_buf(2 downto 0); -- Записываем комманду
				ur_nbt(5) <= '0';
				ur_nbt(4 downto 0) <= ur_buf(7 downto 3); -- Записываем количество байт
			end if;
		elsif (ur_bcount = 3) then
			if (header_flag = '1') then
				if (ur_com = "010" or ur_com = "100" or ur_com = "101") then -- Если команда записи в регистр
					if (ur_buf < x"10") then -- Проверяем адрес регистра
						ur_regadr(3 downto 0) <= ur_buf(3 downto 0); -- И заносим адрес регистра
					end if;
					
				elsif (ur_com = "011") then -- Если команда чтения из регистра
					if (ur_buf < x"10") then -- Проверяем адрес регистра
						ur_regadr(3 downto 0) <= ur_buf(3 downto 0); -- И заносим адрес регистра
						ur_trig <= not ur_trig; -- Запускаем триггер 
						header_flag:= '0'; -- Сбрасываем флаг заголовка
					end if;	
				elsif (ur_com = "000" or ur_com = "001") then -- Если команда работы с RAM
					ur_ramadr(7 downto 0) <= ur_buf; -- Заносим адрес RAM в low
				end if;	
			end if;
		elsif (ur_bcount = 4) then 
			if (header_flag = '1') then
				if (ur_com = "010" or ur_com = "100" or ur_com = "101") then -- Если команда записи в регистр
					ur_data <= ur_buf; -- Заносим дату
					ur_trig <= not ur_trig; -- Запускаем триггер
					header_flag:= '0'; -- Сбрасываем флаг заголовка		
				elsif (ur_com = "000" or ur_com = "001") then -- Если команда работы с RAM
					ur_ramadr(13 downto 8) <= ur_buf(5 downto 0); -- Заносим адрес RAM в mid
				end if;	
			end if;
		elsif (ur_bcount = 5) then 
			if (header_flag = '1') then
				if (ur_com = "000") then -- Если команда записи в RAM
					--ur_ramadr(23 downto 16) <= ur_buf; -- Заносим адрес RAM в high
				elsif (ur_com = "001") then -- Если команда чтения из RAM
					--ur_ramadr(23 downto 16) <= ur_buf; -- Заносим адрес RAM в high
					ur_trig <= not ur_trig; -- Запускаем триггер
					header_flag:= '0'; -- Сбрасываем флаг заголовка		
				end if;	
			end if;
		elsif (ur_bcount > 5) then
			if (header_flag = '1') then
				if (ur_com = "000") then -- Если команда записи в RAM
					ur_data <= ur_buf; -- Заносим данные для RAM
					ur_trig <= not ur_trig; -- Запускаем триггер 
					ur_ramadr <= ur_ramadr + 1; -- Увеличиваем адрес записи на 1
				end if;	
			end if;
		end if;
		state:= 0;
	end if;
end if;
end process;



-- UART send
process (clk)
variable state: integer range 0 to 63; -- Состояние
variable count_p: integer range 0 to per + 1; -- Счетчик периода бита
variable count_bit: integer range 0 to 8; -- Счетчик битов
variable uaramsend_ctg: std_logic:= '0'; -- Контрольный триггер отправки
variable uaregsend_ctg: std_logic:= '0'; -- Контрольный триггер отправки
begin
if (reset = '0') then
	uaramsend_ctg:= uaramsend_trig;
	uaregsend_ctg:= uaregsend_trig;
	count_p:= 0;
	count_bit:= 0;
	state:= 0;
elsif (rising_edge(clk) and reset = '1') then
	if (state = 0) then -- Состояние 0. Установка переменных. Инициализация
		uart_tx <= '1'; -- Задаем 1 на линии
		uswork_flag <= '0'; -- Флаг работы = 0
		state:= 1;
	elsif (state = 1) then -- Состояние 1. Первичное ожидание триггеров
		if (uaramsend_trig /= uaramsend_ctg) then -- Проверяем триггер от RAM
			uaramsend_ctg:= uaramsend_trig;
			us_buf<= data_uaramr; 
			uswork_flag <= '1'; -- Устанавливаем флаг работы
			state:= 2;
		elsif (uaregsend_trig /= uaregsend_ctg) then -- Проверяем триггер от регистров
			uaregsend_ctg:= uaregsend_trig;
			us_buf<= data_uaregr;
			uswork_flag <= '1'; -- Устанавливаем флаг работы
			state:= 2;
		end if; 
	elsif (state = 2) then -- Состояние 2. Старт бит
		if (count_p < per) then -- Таймер периода
			uart_tx <= '0'; -- Устанавливаем 0
			count_p:= count_p + 1;
		else
			count_p:= 0;
			state:= 3;
		end if;
	elsif (state = 3) then -- Состояние 3. Отправка битов
		if (count_bit < 8) then -- Счетчик отправленных битов
			if (count_p < per) then -- Таймер периода
				count_p:= count_p + 1;
				uart_tx <= us_buf(0); -- Выставляем значение из буфера
			else
				count_p:= 0;
				count_bit:= count_bit + 1;
				us_buf<= to_stdlogicvector(to_bitvector(us_buf) ror 1); -- Сдвигаем буфер на 1 вправо
			end if;
		else
			count_bit:= 0; -- Обнуляем счетчик битов
			state:= 4; -- Переходим на стоп бит	
		end if;
	elsif (state = 4) then -- Состояние 4. Стоп бит
		if (count_p < per) then -- Таймер периода
			uart_tx <= '1'; -- Устанавливаем 1
			count_p:= count_p + 1; 
		else
			count_p:= 0;
			state:= 0;
		end if;
	end if;
end if;
end process;

End;